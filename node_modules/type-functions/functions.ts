import { ConcatTuple } from "./tuples";

/** 获取函数参数类型 */
export type GetParametersAsNamedTuple<T> = T extends (
  ...args: infer X
) => infer _
  ? X
  : never;

/** 获取函数返回值类型 */
export type GetReturnType<T> = T extends (...args: infer _) => infer X
  ? X
  : never;

/** 由形参类型列表和返回值类型构造函数类型 */
export type NamedTupleToFunctionType<ParameterT extends [...any], ReturnT> = (
  ...args: ParameterT
) => ReturnT;

/** 给函数增加一个（或多个）参数 */
export type AddParams<
  FuncT,
  ParamsT extends [...any]
> = FuncT extends NamedTupleToFunctionType<infer P, infer R>
  ? NamedTupleToFunctionType<ConcatTuple<P, ParamsT>, R>
  : never;

/** 修改函数的返回值类型 */
export type OverrideFunctionReturnType<FuncT, NewReturnT> =
  FuncT extends NamedTupleToFunctionType<infer P, infer _>
    ? NamedTupleToFunctionType<P, NewReturnT>
    : never;

/** 构造两个给定函数的组合类型 */
export type CompositionType<F1, F2> = F1 extends (...x: infer X) => infer Y
  ? F2 extends (x: Y) => infer Z
    ? (...args: X) => Z
    : never
  : never;

/** 两个给定函数的可组合性判定 */
export type ComposabilityTest<F1, F2> = CompositionType<F1, F2> extends never
  ? false
  : true;

/** 由参数列表和返回值类型构造柯里化函数类型 */
type FuncMaker<P extends [...any], R> = NamedTupleToFunctionType<P, R>;
export type CurryFuncMaker<ParamsT, ReturnT> = ParamsT extends []
  ? FuncMaker<[], ReturnT>
  : ParamsT extends [infer HeadParamT]
  ? FuncMaker<[HeadParamT], ReturnT>
  : ParamsT extends [infer HeadParamT, ...infer Rest]
  ? FuncMaker<[HeadParamT], CurryFuncMaker<Rest, ReturnT>>
  : never;

/** 将一个多对一函数类型转为一个柯里化函数类型 */
export type Currifying<FuncT> = FuncT extends FuncMaker<
  infer ParamsT,
  infer ReturnT
>
  ? CurryFuncMaker<ParamsT, ReturnT>
  : never;
