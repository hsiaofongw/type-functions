/** 连接两个 Tuple */
export type ConcatTuple<T, S> = T extends [...args: infer X]
  ? S extends [...args: infer Y]
    ? [...X, ...Y]
    : never
  : never;

/** 取 Tuple 首元素 */
export type Head<T extends [...any]> = T extends [infer HeadT, ...infer _]
  ? HeadT
  : never;

/** 取 Tuple 余项 */
export type Rest<T extends [...any]> = T extends [infer _, ...infer R] ? R : [];

/** 构造给定长度的 Tuple */
type MakeTupleImpl<
  Len extends number,
  T extends [...any],
  EleT
> = T["length"] extends Len ? T : MakeTupleImpl<Len, [EleT, ...T], EleT>;

export type MakeTuple<Len extends number, EleT = undefined> = MakeTupleImpl<
  Len,
  [],
  EleT
>;

/** 比较两个 Tuple 的长度 */
export type IsTupleLengthEqualOrGreaterThan<
  T1 extends [...any],
  T2 extends [...any]
> = T1["length"] extends T2["length"]
  ? true
  : T2["length"] extends 0
  ? true
  : T1["length"] extends 0
  ? false
  : IsTupleLengthEqualOrGreaterThan<Rest<T1>, Rest<T2>>;

/** 比较数字的大小 */
export type GreaterThanOrEqual<
  X extends number,
  Y extends number
> = IsTupleLengthEqualOrGreaterThan<MakeTuple<X>, MakeTuple<Y>>;

type GetMinImpl<
  MinValue extends number,
  LhsArray extends [...any],
  RhsArray extends [...any]
> = RhsArray extends []
  ? { minValue: MinValue; restArray: LhsArray }
  : RhsArray extends [infer HeadT, ...infer RestT]
  ? HeadT extends number
    ? GreaterThanOrEqual<MinValue, HeadT> extends true
      ? GetMinImpl<HeadT, [MinValue, ...LhsArray], RestT>
      : GetMinImpl<MinValue, [HeadT, ...LhsArray], RestT>
    : GetMinImpl<MinValue, LhsArray, RestT>
  : never;

/** 取非空数字元组的最小元素 */
export type GetMin<T> = T extends []
  ? never
  : T extends [infer HeadT, ...infer Rest]
  ? HeadT extends number
    ? GetMinImpl<HeadT, [], Rest>
    : GetMin<Rest>
  : never;

/** 对数字元组进行排序 */
export type SortNumsAscending<NumsT> = NumsT extends []
  ? []
  : NumsT extends [infer HeadT, ...infer RestT]
  ? HeadT extends number
    ? [
        GetMin<[HeadT, ...RestT]>["minValue"],
        ...SortNumsAscending<GetMin<[HeadT, ...RestT]>["restArray"]>
      ]
    : SortNumsAscending<RestT>
  : never;

/** 获取函数参数类型 */
export type GetParametersAsNamedTuple<T> = T extends (
  ...args: infer X
) => infer _
  ? X
  : never;

/** 获取函数返回值类型 */
export type GetReturnType<T> = T extends (...args: infer _) => infer X
  ? X
  : never;

/** 由形参类型列表和返回值类型构造函数类型 */
export type NamedTupleToFunctionType<ParameterT extends [...any], ReturnT> = (
  ...args: ParameterT
) => ReturnT;

/** 给函数增加一个（或多个）参数 */
export type AddParams<
  FuncT,
  ParamsT extends [...any]
> = FuncT extends NamedTupleToFunctionType<infer P, infer R>
  ? NamedTupleToFunctionType<ConcatTuple<P, ParamsT>, R>
  : never;

/** 修改函数的返回值类型 */
export type OverrideFunctionReturnType<FuncT, NewReturnT> =
  FuncT extends NamedTupleToFunctionType<infer P, infer _>
    ? NamedTupleToFunctionType<P, NewReturnT>
    : never;

/** 构造两个给定函数的组合类型 */
export type CompositionType<F1, F2> = F1 extends (...x: infer X) => infer Y
  ? F2 extends (x: Y) => infer Z
    ? (...args: X) => Z
    : never
  : never;

/** 两个给定函数的可组合性判定 */
export type ComposabilityTest<F1, F2> = CompositionType<F1, F2> extends never
  ? false
  : true;

/** 由参数列表和返回值类型构造柯里化函数类型 */
type FuncMaker<P extends [...any], R> = NamedTupleToFunctionType<P, R>;
export type CurryFuncMaker<ParamsT, ReturnT> = ParamsT extends []
  ? FuncMaker<[], ReturnT>
  : ParamsT extends [infer HeadParamT]
  ? FuncMaker<[HeadParamT], ReturnT>
  : ParamsT extends [infer HeadParamT, ...infer Rest]
  ? FuncMaker<[HeadParamT], CurryFuncMaker<Rest, ReturnT>>
  : never;

/** 将一个多对一函数类型转为一个柯里化函数类型 */
export type Currifying<FuncT> = FuncT extends FuncMaker<
  infer ParamsT,
  infer ReturnT
>
  ? CurryFuncMaker<ParamsT, ReturnT>
  : never;

/** 用 key 构造 object 类型 */
export type ConstructObjectTypeByKey<T extends string, ValueT> = {
  [KeyT in T]: ValueT;
};

/** 用 infer 类型推导功能实现 keyof 操作符 */
export type InferBasedKeyof<T> = T extends ConstructObjectTypeByKey<
  infer KeysT,
  any
>
  ? KeysT
  : never;

/** 给一个 object 类型的各字段都加上 optional 修饰（? 修饰，也叫问号修饰） */
export type AddOptionalToFields<T extends object> = {
  [Property in keyof T]+?: T[Property];
};

/** 去掉 optional 修饰 */
export type RemoveOptionalFromFields<T extends object> = {
  [Property in keyof T]-?: T[Property];
};

/** 递归地去掉 optional 修饰 */
export type RecursivelyRemoveOptionalFromFields<T> = T extends object
  ? {
      [Property in keyof T]-?: RecursivelyRemoveOptionalFromFields<T[Property]>;
    }
  : T;

/** 递归地加上 optional 修饰 */
export type RecursivelyAddOptionalToFields<T> = T extends object
  ? {
      [Property in keyof T]+?: RecursivelyAddOptionalToFields<T[Property]>;
    }
  : T;

/** 子集关系判定 */
export type Extends<T, S> = T extends S ? true : false;

/** 分支范型 */
export type If<Cond, TrueT, FalseT> = Cond extends true ? TrueT : FalseT;

/** 或 */
export type Or<Cond1, Cond2> = Extends<true, Cond1 | Cond2>;

/** 否 */
export type Not<Cond> = If<Extends<true, Cond>, false, true>;

/** 与 */
export type And<Cond1, Cond2> = Not<Extends<false, Cond1 | Cond2>>;

/** 判定联合类型中是否包含 null 或者 undefined */
export type NullableTest<T> = Or<Extends<null, T>, Extends<undefined, T>>;

/** 获取非 optional 字段 */
export type ExtractNonOptionalProperties<T extends object> = {
  [Key in keyof T as If<NullableTest<T[Key]>, never, Key>]: T[Key];
};

/** 获取 optional 字段 */
export type ExtractOptionalProperties<T extends object> = {
  [Key in keyof T as If<NullableTest<T[Key]>, Key, never>]: T[Key];
};

/** Union 从属关系判定：若 T 是联合类型 U 的元素，返回 true, 否则返回 false */
export type UnionElementTest<T, U> = U | T extends U ? true : false;

/** 是否值类型元素（类型分为值类型和引用类型） */
export type IsValueType<T> = UnionElementTest<
  T,
  number | string | boolean | undefined | null | symbol
>;

/** Tuple 转 Union */
export type TupleToUnion<T extends [...any]> = T extends []
  ? never
  : T extends [infer X, ...infer Y]
  ? X | TupleToUnion<Y>
  : never;

/** 等性判定 */
export type EqualTest<T, S> = And<Extends<T, S>, Extends<S, T>>;

/** Tuple 从属关系判定：给定的元素在元组中是否存在？ */
export type TupleElementTest<EleT, TupleT> = TupleT extends []
  ? false
  : TupleT extends [infer HeadT, ...infer Rest]
  ? HeadT extends EleT
    ? EleT extends HeadT
      ? true
      : TupleElementTest<EleT, Rest>
    : TupleElementTest<EleT, Rest>
  : false;
