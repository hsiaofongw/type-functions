/** 连接两个 Tuple */
export type ConcatTuple<T, S> = T extends [...args: infer X]
  ? S extends [...args: infer Y]
    ? [...X, ...Y]
    : never
  : never;

/** 取 Tuple 首元素 */
export type GetFirstFromTuple<T extends [...any]> = T extends [
  infer HeadT,
  ...infer _
]
  ? HeadT
  : never;

/** 取 Tuple 余项 */
export type GetRestFromTuple<T extends [...any]> = T extends [
  infer _,
  ...infer R
]
  ? R
  : [];

/** 构造给定长度的 Tuple */
type MakeTupleImpl<
  Len extends number,
  T extends [...any],
  EleT
> = T["length"] extends Len ? T : MakeTupleImpl<Len, [EleT, ...T], EleT>;
export type MakeTuple<Len extends number, EleT = undefined> = MakeTupleImpl<
  Len,
  [],
  EleT
>;

/** 比较两个 Tuple 的长度 */
type Rest<T extends [...any]> = GetRestFromTuple<T>;
export type IsTupleLengthEqualOrGreaterThan<
  T1 extends [...any],
  T2 extends [...any]
> = T1["length"] extends T2["length"]
  ? true
  : T2["length"] extends 0
  ? true
  : T1["length"] extends 0
  ? false
  : IsTupleLengthEqualOrGreaterThan<Rest<T1>, Rest<T2>>;

/** 比较数字的大小 */
export type IsGreaterOrThan<
  X extends number,
  Y extends number
> = IsTupleLengthEqualOrGreaterThan<MakeTuple<X>, MakeTuple<Y>>;

type GTE<X extends number, Y extends number> = IsGreaterOrThan<X, Y>;
type GetMinImpl<
  MinValue extends number,
  LhsArray extends [...any],
  RhsArray extends [...any]
> = RhsArray extends []
  ? { minValue: MinValue; restArray: LhsArray }
  : RhsArray extends [infer HeadT, ...infer RestT]
  ? HeadT extends number
    ? GTE<MinValue, HeadT> extends true
      ? GetMinImpl<HeadT, [MinValue, ...LhsArray], RestT>
      : GetMinImpl<MinValue, [HeadT, ...LhsArray], RestT>
    : GetMinImpl<MinValue, LhsArray, RestT>
  : never;

/** 取非空数字元组的最小元素 */
export type GetMin<T> = T extends []
  ? never
  : T extends [infer HeadT, ...infer Rest]
  ? HeadT extends number
    ? GetMinImpl<HeadT, [], Rest>
    : GetMin<Rest>
  : never;

/** 对数字元组进行排序 */
export type SortNumsAscending<NumsT> = NumsT extends []
  ? []
  : NumsT extends [infer HeadT, ...infer RestT]
  ? HeadT extends number
    ? [
        GetMin<[HeadT, ...RestT]>["minValue"],
        ...SortNumsAscending<GetMin<[HeadT, ...RestT]>["restArray"]>
      ]
    : SortNumsAscending<RestT>
  : never;

/** 获取函数参数类型 */
export type GetParametersAsNamedTuple<T> = T extends (
  ...args: infer X
) => infer _
  ? X
  : never;

/** 获取函数返回值类型 */
export type GetReturnType<T> = T extends (...args: infer _) => infer X
  ? X
  : never;

/** 由形参类型列表和返回值类型构造函数类型 */
export type NamedTupleToFunctionType<ParameterT extends [...any], ReturnT> = (
  ...args: ParameterT
) => ReturnT;

/** 给函数增加一个（或多个）参数 */
export type AddParams<
  FuncT,
  ParamsT extends [...any]
> = FuncT extends NamedTupleToFunctionType<infer P, infer R>
  ? NamedTupleToFunctionType<ConcatTuple<P, ParamsT>, R>
  : never;

/** 修改函数的返回值类型 */
export type OverrideFunctionReturnType<FuncT, NewReturnT> =
  FuncT extends NamedTupleToFunctionType<infer P, infer _>
    ? NamedTupleToFunctionType<P, NewReturnT>
    : never;

/** 构造两个给定函数的组合类型 */
export type CompositionType<F1, F2> = F1 extends (...x: infer X) => infer Y
  ? F2 extends (x: Y) => infer Z
    ? (...args: X) => Z
    : never
  : never;

/** 两个给定函数的可组合性判定 */
export type ComposabilityTest<F1, F2> = CompositionType<F1, F2> extends never
  ? false
  : true;

/** 由参数列表和返回值类型构造柯里化函数类型 */
type FuncMaker<P extends [...any], R> = NamedTupleToFunctionType<P, R>;
export type CurryFuncMaker<ParamsT, ReturnT> = ParamsT extends []
  ? FuncMaker<[], ReturnT>
  : ParamsT extends [infer HeadParamT]
  ? FuncMaker<[HeadParamT], ReturnT>
  : ParamsT extends [infer HeadParamT, ...infer Rest]
  ? FuncMaker<[HeadParamT], CurryFuncMaker<Rest, ReturnT>>
  : never;

/** 将一个多对一函数类型转为一个柯里化函数类型 */
export type Currifying<FuncT> = FuncT extends FuncMaker<
  infer ParamsT,
  infer ReturnT
>
  ? CurryFuncMaker<ParamsT, ReturnT>
  : never;

/** 用 key 构造 object 类型 */
export type ConstructObjectTypeByKey<T extends string, ValueT> = {
  [KeyT in T]: ValueT;
};

/** 用 infer 类型推导功能实现 keyof 操作符 */
export type InferBasedKeyof<T> = T extends ConstructObjectTypeByKey<
  infer KeysT,
  any
>
  ? KeysT
  : never;

/** 给一个 object 类型的各字段都加上 optional 修饰（? 修饰，也叫问号修饰） */
export type AddOptionalToFields<T extends object> = {
  [Property in keyof T]+?: T[Property];
};

/** 去掉 optional 修饰 */
export type RemoveOptionalFromFields<T extends object> = {
  [Property in keyof T]-?: T[Property];
};

/** 递归地去掉 optional 修饰 */
export type RecursivelyRemoveOptionalFromFields<T> = T extends object
  ? {
      [Property in keyof T]-?: RecursivelyRemoveOptionalFromFields<T[Property]>;
    }
  : T;

/** 递归地加上 optional 修饰 */
export type RecursivelyAddOptionalToFields<T> = T extends object
  ? {
      [Property in keyof T]+?: RecursivelyAddOptionalToFields<T[Property]>;
    }
  : T;
