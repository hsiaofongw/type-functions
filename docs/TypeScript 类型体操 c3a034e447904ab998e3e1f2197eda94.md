# TypeScript 类型体操

# 引言

在 TypeScript 语言模型中，~~类型（视为对象）和类型之间的转换关系（视为态射）构成一个范畴~~，也就是说，你可以像在 JavaScript 中操作 object 那样在 TypeScript 中操作类型，正如同在 JavaScript 语言模型中，可将 object 视为对象，将 function 视为态射。

同样不严谨地说，类型在 TypeScript 语言中可以视作基本的、平凡的东西，TypeScript 语言本身提供了一些方式使得对这类「类型对象」的操作变得便捷，这些「类型对象」多少类似于 JavaScript 中的普通对象那样，可以被创建，可以取出部分，可以被当作参数传进函数中并且作为函数返回值返回给所谓的调用者，我们在这篇文章中主要就是举例这些方法的使用。

你可以在 [TypeScript Playground](https://www.typescriptlang.org/play?#code/PTAEnbgw15UX8VAdTQh5Vobx9DR6gKAC4E8AOBTUAWSwDEBXAOwGMAVXPARlAF5QAKAQwC5QKyBbAEZ4ATgBpQgngGcMIgJYUA5hKo9BAew0AbPBwoBKFgD5eA4SIDcmekVKVa9AEwt2R5qYBuG+QBNrNvigAOJ4GAAKHCIc-GGi0gCC0gByMXi+NGQ4ugA8NKasNKB4AB4YeBS+0uwAdHVRStI8igBmoqAAGu6mre0A+qAA-J2gPBR4nqIB2EHhTKyhEVFp5SKJKWkZWbnE5NR0+AymoCCgANrcZkKiElKgsgrKqupauvoAuoEE4S4LYZHRWKrdapWJbbJ4HK7BwHPBOY6nM6fNCnKBwQAr8YA9tUAPAqoL4hMIAJTCZBEFFheQKoCKpXKlWqbDqNQaTVAvREoD63TZFDaHI6QxGYwmUzQ+MJ8wJGGJGFJ5PoUPs+3oR0soBOYD41xE4t+Uplcop0OV+Hhao1oG8fjFp0Ae-GAUuNACRygCo5anbPD4gDCGmoHAwmQheQkAGUqTSyhUqucmSzmrz2h13oK2MHihH6dH6iJGnG+aAAJpJ4ZnJkdCRMwujXgijlGYWTHX4gO6BKuC5jcw3UBqSSvPQUT4zAjNvAAITbvhkckUSiREjwU8eSkHthHCT649Y3t9-vdeXdCQkI9HCLA7auFmevZ0-Ykk-u0+Uc+Ki5nyKHbohABE2w8ZxI-yeB8lyRFcghHABRNtNBvfRny1S8L1EJFQKbd0vz6KCtx9Kg-RHfdvyPd0INPc5AJUYD-0op93luPs4NopDxCYlD3mRU5AEZXRBAHQlQALCMACH-AAA5V1QXSEdqXoQBIf8AGJUsVxFBABDzQACBOEuA8Q-UTwV0GgND2KgMHkH0KQBFZRHDOkoxLeoKCwRiDTJfJXEZLMc1AEygTM7l7PJAJTkATb84EAPI1AAKlYT+MANCNACxNZ1JMQfEEl8Xx3OkHI9JoCRkvMyNqis5kbPeKk0rTCzqk0kcdL0gyjIVdk3IkWrCVMYYyvdCqHCq+V8BybdcN3QNwgy5Z+GkfIJEaqtxgbMUP2NRx8AAFlcBKkqGlK0HVNgSg7bUJCwV9lG5K1fAkdbzgAL22ixWIkS4YLeAc0FIzbLq7PbqIoi6WPeZ9bvowwTEtHxfBtMBADv5QBOUzgQAQtzk9TbAAeQbBRfDwSrDIobyKTSiRkjwAB3THCphYrstAFqITa6gOopWqBp5PM+iasnNnK3T2vR4ycfxwmJprawZqVOa8AAVlcRHRGR1H2Z9TGFU4HgEhEaIsBycjjEOoG6NgihjF8sBAApXUAAGs8CwUBlNADRBAAKzwfTQDhoJtweMh9Phm27f9ehRywABpU28hJjNyIkAA1DhtDIPBHNYABvU71TOf2sCKRRqXeHhw8j6O0AAX2m2wSC0VxnbkV2MHd239NhH3k5yAByFotHr0AAB9QHrwQohb9vO44M764kBDkIK6xTg-IuNFcePTnVJuNBekQkTHsB1S7kRF+XlFV8kfvN-eFfQHz-EAElpEniD0yqSvPdcSeg6jK2q4wQUy4IHgWgj6QCAtN-T-PrQl8SqK2VvDFoN97asHvrSUmT9PZIlfiIKOVZP7aG-uqU4qDv7-wvlfaQJ8MDBjwNoFod9i4wIzPfYYb8UFfx-uPJBHpt6gENrVVAgAK40AD-agB8pUAL8BgA87UAA3OxtTYaFIYAWZNAA68oAMm9T7xhEKODg39fDJzEZSVwWUMylyQW7D21dvZ+wDrVZOI0bo2SZiYoo9ZRQfhMWA++rAT7yMUco1RLRUpaF1hgsAAAieePi26gB8evAJ7dgn9x8SDUAflhKWz0S-VAUNAAgKoAdW1ACt1oAX4TgqACg5S2OAOoR1AKDQADpn8WGCUwAMP+AH05QA18qADvUwA78olMkvFRK8N8nowjhVeQxCqiBwoY-eJVJ47qkTuEEQGh8AiGwDyERWAxHpwANSDB4DQM44zJmiGwJ8Y+H52kFO0A40Ay19mdO0N03pKVJ7GGYXsjpPoI5HJnjveeKyvqBMoCjFoih0iHzXlEN5w8l5Jnbp8vA3zxj+GYf8s6gLOzAo+ZUcFPyoWnGPqcQA3cqAEjjPJByinFPFHgfgGhJinIeYciZ-ASA9O0H0zRgzn7DITucDZUyZlpxNvM0hNB3gAFo3lrNZVs2yecC5BGSD6MlFBHnF1YMSYlpL7nSopRoKlNK+lSplRoXW-8JUUE1YcwBeCjl6oNdAvBoAqGgBoR-Oh5oGFRyiYAJATABK+oABnVsW4rOfiwlVBSTSHkJMbQWB5UkrwGayl1LLnqMKA-aocD7bDBGaM9ZEy2Vmw5aI7lfK3nEj9WsQNxCQ1ErDRG1VUbaUpUFWm4VBU85VhoNMWwwZVV4FxrIdIBrYTT2ZRwBgbzk2jNGRwJwA7mVDqHRwAAzHC7U47Rn5yHbnawQ7BCzqut9A+zKqBvLuv2awuzm2tolV22wcq7b+sLcG0NiqDkkEjeqlKLbYjtvKL4U9+AdXMNdW6nJXryU+o-Hmy9QasAnKVV03Sj6Y3UjjXE5+gpB0sprdMjNFA5kLJ5csngwGC2gfAwci5la8ips2ahutucG1NqCAa1s5780Bvw20iD5yoPRufW2jQH68BftOAAVQoOjUAgA5uUAHo6gBnRUAN8+gASJUAFnagAsf8AKdBsHAD0ZoAFQDAAQKqgUAfHQBQ0AMKKgACXwqVia1jCJCADIVQAmEqmawR6D8An0YQV0LECg-o8CyCDDpqkbBdPtxoEYAZ1RdPUMYbQtBeBqMEAgpKRzPpnNEoqO5zzQKh7wq8b-Rh+IIJ6jixQBLrnksYByEdNL2oMuYLodlqdrg8sFaSzQDzxXUtMVbmre1YA-4fggotVgdWXMNaa6rR8FEgVtZGxVzrWXuuiz64J+LA23ONc83u-QZWLDjaXJN0AdnssADZavzfy4torOQxsh3ett3b3WADsh2nMneW81msAEJsdbM465hKmLPySM-xVAgAwJUAFxy8lpKAFR9fWqAWkfjPlnKOFIY46aO-VpbQ30pMUCeRQJq30OgqRRC9IgS+DaG0JjrAQgdA3Jh6HSUsOI7w4VEC7bXXbAn1DnqOn2cKRAqRFdqr1OauOOkHD6OCoE0YD5xF0+odeugE5wzrq9cOD12Z+ZyQdsOBkHQUrluQX3o1CieFQAoAH4nhiIbqPpfAMAkNuXw8InI0PbrbpgTvLdOECxatgzvAm2-d4g5BtqIv8wRpKM3OQ7MSDs14yrUu9l6jDxHj7PH3ss5o4L0AYe36R7oarx1ezZeZ7V2-aPU3PunG+2YEnoBjegDBQT4GGkyAk44IIbSaOqRh-64l1HKWm-aCPMYCQXfCtPZyHXlFA+dUw-hpKZIfeW9t88+PyFuf7Os-hnqOfzfW-RyG8T7Qq-T7w3T1v7QC-d+9+1K3ffJek9H9l6f8-o+xvL-SLf1PBAT7w1m2TefO-R-kRIitzi6sStyv6+Dv7Tbr4HasCP7-577pZqgx7YLT53awF-6L7FaAGjwWjXbr4AAcrgcBmBOQ4ut+u2zC4kgANvFI7oxoQUwaB5b9IWq5T6C2RhhwYILDCTTtCrKcG1RligBMi1SVjDBsACj+atSMFHY5D5jqy8wNjB5BB5b3qqriSFBSFMFnAXYtbi44EWhY7txAqBLi5RKACS3oAOQGcm2WAAjmQF0mjiGBwXrqmGIamHrkUKFgHjtnQnWD4UHlEuJGJlJnJvJhXuVKAIAHrpgAXl6ABueoAChygAGtqAAU6p+NpKAIALRyUMgAC+bOhGawaAD+8oAOn6oAEEdhDhnm6OCWjkeuNCgACEaADTXoAPj-9BugKOp21RREFMVIp0EReuXB-h6CPAvRrU-B8ioAAAEnoBkOWHUA1E1kWBnubmUfYeckNp0ZMdMaNGkXgO0aPhscSLIMYKYIHt-FFtSDFhosRI9kNhdrzu9ngeBDllcRCHsbcSNhINoSNvoQ6mvk8enpBDcZfohF8UuD8WAI8cOD1i8W0UCc1vCp8SHECuCXfh+DQBBD-oCd3qdjzoxKCf+MiZLigauBBDATsW8cCSPIiR8biWIISSnllswpADsaAIAGmZRm+Iiw1KawGAqh-A+EiO9KOUtUUxHAMxQhcx4xfQixopGQChNitgwQkoXJ8gPJfJ+EZwqW2Br2IEm662ogo8nJeoKpaplKGp7010TEhpzCAOgA9KaADAwegDDu4rbkeIwujiQHQojrbnBjQsMDQO6VWJ6RFo2lElAJEf+sqqAOktlmUNEPpKaixkKtMj0lWnBmQT2kOknKbLMpyphqAEonLu4sQRfsVmssnAVEPC9qAMnMYBnNSNmbZAemKgQIQPICUGJCqJmcOm8o3M3IEn3CIPXCuqMmuvvFvEOj2DjiOeqPeECgeucYmQcvDBQG2R2RkF2awEAvGRgEuWcsmQZB5lCO2Z2YcDqqcPDGQBgDgFeTwLHN2C8NrGqHOfCmqOimAFAJGYUjGd1nGRwG7EmShoeWmXrhmXHMyo2bmVmrBoWSfMWRgaWSRhWYPjWabFWQ2HWaso2VuoeuKpKixiuWuaeXCK4Nuf+RXIBWRsBceeubCKqMwpedebeaAPeRwL2fPD3B3OvJxeAWqGOV9Agnjl8iim+WKEAA) 中尝试或者验证文中的代码，并且通过将鼠标 hover 到类型名称上查看该类型名称背后指代的具体类型。

这篇文章尝试帮助读者增进对于 TypeScript 类型系统以及 TypeScript 类型编程方法的熟悉程度，并且尝试给元编程爱好者带来乐趣。

# 模式匹配与类型推导

TypeScript 的类型系统之所以强大，其原因之一就是语言层面提供了针对类型对象的模式匹配功能，具体来说就是 `infer` 关键字，这个模式匹配功能可以实现很灵活、丰富的类型操纵，下面通过例子来看怎么用。

## Tuple 型类型对象的操纵方法与类型推导方法

Tuple 型类型对象是 TypeScript 中看起来比较简单的，我们接下来通过它来演示 `infer` 关键字和 `extends` 关键字的使用。

### Tuple 型类型对象的连接操作

Tuple 型类型对象描述的是一个 Tuple 对象有几个值，第几个值分别对应什么类型，刚才我们获取到的函数参数类型是以 Tuple 类型的形式存在的，那么我们现在想尝试实现对 Tuple 类型的操纵，就如同对具体 Tuple 对象的操纵一样：

下列是两个 Tuple 类型对象的连接操纵，它尝试 infer 出两个 Tuple 类型对象中的元素，然后拿 infer 到的结果组建新的 Tuple 类型对象：

```tsx
// 连接两个 Tuple
type ConcatTuple<T, S> = T extends [...args: infer X]
  ? S extends [...args: infer Y]
    ? [...X, ...Y]
    : never
  : never;
```

通过下列方式来使用它：

```tsx
type TupleA = [a: number, c: boolean];
type TupleB = [d: string[], e: string];
type TupleA_B = ConcatTuple<TupleA, TupleB>; // [a: number, c: boolean, d: string[], e: string]

type TupleD = [string, string, string[]];
type TupleE = [boolean[], number, number[][]];
type TupleD_E = ConcatTuple<TupleD, TupleE>; // [string, string, string[], boolean[], number, number[][]]
```

### Tuple 型类型对象的取首项操作

以下代码演示如何尝试获取一个给定 Tuple 的第一个元素，如果取不到就返回 `never`:

```tsx
// 取 Tuple 首元素
type GetFirstFromTuple<T> = T extends [infer HeadT, ...infer _] ? HeadT : never;
type G1 = GetFirstFromTuple<[number, string[], string[][], number]>;
type G2 = GetFirstFromTuple<[string[][], number]>;
```

### Tuple 型类型对象的取余项操作

类似取首项的实现思路，同样借助 `infer` 关键字和 parameter pack:

```tsx
// 取 Tuple 余项
type GetRestFromTuple<T> = T extends [infer HeadT, ...infer RestT]
  ? RestT
  : never;
type RestType1 = GetRestFromTuple<[string[], boolean, number]>; // [boolean, number]
type RestType2 = GetRestFromTuple<[]>; // never
type RestType3 = GetRestFromTuple<number>; // never
```

### Tuple 型类型对象与数字类型对象的互相转化操作

Tuple 类型对象最有意思的一点是它支持 `['length']` 操作，比如说：

```tsx
type SomeTuple = [number, string[], boolean];
type LengthOfTuple = SomeTuple["length"]; // 3
```

这样就能够把 Tuple 类型对象转换为一个 extends `number` 类型的 `number` 子类型对象。

那么自然地，我们会想到，要把 number 转到 Tuple 类型对象，只要构造一个相应长度的 Tuple 类型对象就可以了，实现的思路是这样：我们从一个空 Tuple 类型对象开始（长度为 0），看这个 Tuple 类型对象的长度是否等同于给定的 number, 如果不等就增加 Tuple 的长度然后进入下一轮迭代。

如果 number 参数是负数就返回 never, 因为负数长度的 Tuple 类型对象是没有定义的，但这一点不是那么容易做到，所以我们就不判定长度参数 `Len` 的正负号了：

```tsx
type MakeTupleImpl<
  Len extends number,
  T extends [...any]
> = T["length"] extends Len ? T : MakeTupleImpl<Len, [undefined, ...T]>;
type MakeTuple<Len extends number> = MakeTupleImpl<Len, []>;
type T0 = MakeTuple<0>; // []
type T1 = MakeTuple<1>; // [undefined]
type T2 = MakeTuple<2>; // [undefined, undefined]
type T3 = MakeTuple<3>; // [undefined, undefined, undefined]
```

### Tuple 型类型对象的长度比较操作

由于在 TypeScript 中，number 类型对象暂时还不支持直接比较：

```tsx
type IsTwoGreaterThanOne = 2 > 1;  // error
```

所以假如我们想比较 number 类型对象的话，就得从 Tuple 入手：因为 number 可以转为 Tuple, 并且转为 Tuple 之后只需比较长度就可以了。

虽然这样做也有缺点那就是不能够比较负数，因为你不能够方便地把负数转为 Tuple.

但是我们可以比较两个 Tuple 类型对象的长度，我们检查两个 Tuple 的长度，得到两个数字 a 和 b 分别代表各个 Tuple 类型对象的长度，如果 a, b 都 extends 0, 那么说明两个 Tuple 等长，否则如果只有 a extends 0, 说明第二个 Tuple 比第一个长，否则如果只有 b extends 0, 说明第一个 Tuple 比第二个长，如果都不 extends 0, 那么就去掉各自的首元素，并且进入下一轮比较：

```tsx
type Rest<T extends [...any]> = T extends [infer _, ...infer R] ? R : [];

type IsTupleLengthEqualOrGreaterThan<
  T1 extends [...any],
  T2 extends [...any]
> = T1["length"] extends T2["length"]
  ? true
  : T2["length"] extends 0
  ? true
  : T1["length"] extends 0
  ? false
  : IsTupleLengthEqualOrGreaterThan<Rest<T1>, Rest<T2>>;
```

使用下列语句对它进行验证：

```tsx
type ITLEG1 = IsTupleLengthEqualOrGreaterThan<[], []>; // true
type ITLEG2 = IsTupleLengthEqualOrGreaterThan<[undefined], []>; // true
type ITLEG3 = IsTupleLengthEqualOrGreaterThan<[undefined, undefined], []>; // true
type ITLEG4 = IsTupleLengthEqualOrGreaterThan<[undefined], [undefined]>; // true
type ITLEG5 = IsTupleLengthEqualOrGreaterThan<
  [undefined],
  [undefined, undefined]
>; // false
type ITLEG6 = IsTupleLengthEqualOrGreaterThan<[], [undefined, undefined]>; // false
```

### Tuple 型类型对象长度比较操作用于实现数字大小比较操作

那么实现了 Tuple 的长度比较之后，就可以水到渠成地实现数字的大小的比较了：

```tsx
type IsGreaterOrThan<
  X extends number,
  Y extends number
> = IsTupleLengthEqualOrGreaterThan<MakeTuple<X>, MakeTuple<Y>>;

type IGE1 = IsGreaterOrThan<0, 1>; // false
type IGE2 = IsGreaterOrThan<0, 2>; // false
type IGE3 = IsGreaterOrThan<0, 3>; // false
type IGE4 = IsGreaterOrThan<1, 1>; // true
type IGE5 = IsGreaterOrThan<1, 2>; // false
type IGE6 = IsGreaterOrThan<1, 3>; // false
type IGE7 = IsGreaterOrThan<2, 1>; // true
type IGE8 = IsGreaterOrThan<2, 2>; // true
type IGE9 = IsGreaterOrThan<2, 3>; // false
type IGE10 = IsGreaterOrThan<3, 1>; // true
type IGE11 = IsGreaterOrThan<3, 2>; // true
type IGE12 = IsGreaterOrThan<3, 3>; // true
```

在文章后面的章节我们还会发现数字还可以用字符串型类型对象（而不是这里的 Tuple 型类型对象）来编码，事实上我个人觉得这种方式比字符串方式更方便。

### Tuple 型类型对象的数字元素排序操作

在实现比较函数之前先实现 `GetMin` 类型函数，这个类型函数比较有意思：

```tsx
type GetMinImpl<
  MinValue extends number,
  LhsArray extends [...any],
  RhsArray extends [...any]
> = RhsArray extends []
  ? { minValue: MinValue; restArray: LhsArray }
  : RhsArray extends [infer HeadT, ...infer RestT]
  ? HeadT extends number
    ? GTE<MinValue, HeadT> extends true
      ? GetMinImpl<HeadT, [MinValue, ...LhsArray], RestT>
      : GetMinImpl<MinValue, [HeadT, ...LhsArray], RestT>
    : GetMinImpl<MinValue, LhsArray, RestT>
  : never;

type GetMin<T> = T extends []
  ? never
  : T extends [infer HeadT, ...infer Rest]
  ? HeadT extends number
    ? GetMinImpl<HeadT, [], Rest>
    : GetMin<Rest>
  : never;

type M1 = GetMin<[3, 1, 6, 4, 2, 5]>;
type M2 = GetMin<[5, 9, 3, 9, 6]>;
type M3 = GetMin<[10]>;
type M4 = GetMin<[]>;
```

以下是推导结果，它每次返回最小值和剩余数组，如果实在做不到就返回 `never`：

![截屏2023-01-11 下午8.22.33.png](TypeScript%20%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D%20c3a034e447904ab998e3e1f2197eda94/%25E6%2588%25AA%25E5%25B1%258F2023-01-11_%25E4%25B8%258B%25E5%258D%25888.22.33.png)

![截屏2023-01-11 下午8.22.40.png](TypeScript%20%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D%20c3a034e447904ab998e3e1f2197eda94/%25E6%2588%25AA%25E5%25B1%258F2023-01-11_%25E4%25B8%258B%25E5%258D%25888.22.40.png)

![截屏2023-01-11 下午8.22.45.png](TypeScript%20%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D%20c3a034e447904ab998e3e1f2197eda94/%25E6%2588%25AA%25E5%25B1%258F2023-01-11_%25E4%25B8%258B%25E5%258D%25888.22.45.png)

![截屏2023-01-11 下午8.22.49.png](TypeScript%20%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D%20c3a034e447904ab998e3e1f2197eda94/%25E6%2588%25AA%25E5%25B1%258F2023-01-11_%25E4%25B8%258B%25E5%258D%25888.22.49.png)

那么有了这个 `GetMin` 函数之后，要对容纳数字的 Tuple 型类型对象的内容进行排序是非常容易的：只需不断地应用 `GetMin` 操作然后再对剩余数组进行排序即可！以下是具体实现：

```tsx
type SortNumsAscending<NumsT> = NumsT extends []
  ? []
  : NumsT extends [infer HeadT, ...infer RestT]
  ? HeadT extends number
    ? [
        GetMin<[HeadT, ...RestT]>["minValue"],
        ...SortNumsAscending<GetMin<[HeadT, ...RestT]>["restArray"]>
      ]
    : SortNumsAscending<RestT>
  : never;
```

以下是应用：

```tsx
type Array1 = [3, 1, 6, 4, 2, 5];
type Array2 = [5, 9, 3, 9, 6];
type Array3 = [10];
type Array4 = [];

type Sorted1 = SortNumsAscending<Array1>; // [1, 2, 3, 4, 5, 6]
type Sorted2 = SortNumsAscending<Array2>; // [3, 5, 6, 9, 9]
type Sorted3 = SortNumsAscending<Array3>; // [10]
type Sorted4 = SortNumsAscending<Array4>; // []
```

欢迎读者自行在 [TypeScript 游乐场](https://www.typescriptlang.org/play?#code/C4TwDgpgBAsghgawgFQK5gDYQJIFtMA8AMhAHZQQAewZAJgM5Smq4BGEATgDRTIXV1GAbQB0YuKRABdAHxQAvLyEByLKQDmwABbKp-GqQZQS5APy8oALliIU6LHkImeQ1IYgAzAJakItHmIiyLIA3ACwAFCgkDZIaJgQxGT6gkws7BxyivBx9jj4GEmkLqGR0dDIAAwKsXYJBJUyIVBQAPStUEJSZeAVAIw1OXVYBH1NLe2dbrSePn7dUb28AEyDtvEjy+NtHa7u3r7+UNOzhwvlvADMa7n1l9uTezMHfjwnL0fvc7QLPTEAShB6MACHwqAYjKJxJJZDUwQJDMIfB5OFAAPoBMTI1H-PTmf5WTpScIRP7QbD0DYQEyaLQAUQAjqg4BgAPIcADiHAgcBoHGQWgkoIG4NSUJEEmkPGQq1FiM6gUlsMUkV4fRUalpuhS8plGrIWrxUGAHFQ0Esqr1qgN2m1cqM1XMJrNVkt6utGltentjEdUA8LPo5tVFKpNO0jOZbM53N5nAFQsBwOFMh4SZBMpkTUiZKg2GQRDpHIGilDeXD9KZLPZXJ5fITpAIXRKDw6zogufzhY5q1LlPLNsrUZrsfrgsbT1O8xbzR2xtNHcWMS7ReufbDg8j1Zjdfj46bX0Ob323ykM4mbYXnYLRYALDUywkK1vo7W4-z95OPmepiezq35zNa9uwAVgffsn03KtX1HPchS-U8XEPV5jj-eYAIDDAg2AosADZwI3T0h23N8x3gn8EKPVDnlPDDA0XTt6FIzh2QbAgAA0dSMZg2E4HgAE0uMYHiMiyPMIKwZ9oJHXcPyFIYqQ41NakU-isxJTsOTpEtxOYjhWP3SoeDGWdJkw7Cl3JLTe102D9LkxsjKgLZTI6czFwubAtLXWzZIMoUnPuVz-XozS6XvPs9P8xs+mMgD2zCsDIrs6LRh4FyLxCrCPKWLy6Xw5K-IctKoCCzL3LCgB2cCouK5Y4uChLLLzLSAA4apSur0viq9mrygBODqirY+rSro7Kwr6apCvfVLLgazKms8rS+h0ilarY+bnJ6oC+pWmz1s6zaeDKucmtzDlkDpAgAEEhLSXjuCgAAhe6RM4MTDuG-cbp4Z7s2ajkIGAGAfEcQpQdIAA1FkXR9B6Mh4IgtHoG6OA4OAQHu8UlTTFG0YxrH4ZxmExNVKB-nx9HMexo0AG8oFwHwYYwM1rEhlmzR4blgQJzHrGR1HqaxgBfV0IhaSmhcJ7HsQ4KAAAkeVoZBMREOWKaBYBgigcxyZaJW4BVt70lRUx9ZaKBLuujnYYgHhDZVuR4fbXWLctq3gch8GCEd1XOlt1n7agQJBb5qVNeBZA5AtCWPctoGQbBgoCEDrnOj9tWw+Fn902j8X489pPSB9tPg+zwm0y1-PY493wADdOBJeOLq9nxQTJuP4QhYQjQb1Fa4sYmNczkOsVIFF5fTPELb9k3HrduOPcT72U9H5tI+AGP3aLyGCHTbel6YCBG44DTmvDnShHm2LcK4W8uHqkDiVzcObKEECuH6k6v64XCX4vsLHyQgpoAIuOHCKRISQXBgDpFe7dL4AxgTZeBjY35IKWDAHyqDbpAIwTEGAkCcEQIBrmAAygAew4MAAAciwVG9AADGdAfDqAIHQ3AlJO4tA4ZSWmusiQFygLw7uYoR7K39oEDWecZ5HznvDd68tzZHxaEIHBQhR6BBkTIFQTNoZ210GrSh1DeE3SYSwjQBB1GaLENolQPNgDh10DIPQg8PbGNofQsxzDDCsP3tXQ+dcT5NxzM1DxfgdIeNMeY3xljEHQKWOE2gNkoleJibQPx6CEkxCST5VJnDvEWLYeHIK5CqE0FoJA-JDCfEZLicLW8AMgA)体验这些类型操作代码！编写并且测试这些代码真的是非常开心的体验！

### Tuple 型类型对象用于模拟自然数的算术操作

我们希望实现一个类型函数 `Increase` 和 `Decrease` 效果如下：

```tsx
type Two = Increase<1>; // 2
type Eight = Decrease<9>; // 8
```

由于一个 Tuple 型类型对象的「长度」属性可以被轻易获取到，所以这个功能是可以实现的：

```tsx
type Increase<N extends number> = [...MakeTuple<N>, undefined]["length"];
type Decrease<N extends number> = N extends 0
  ? never
  : Rest<MakeTuple<N>> extends [...any]
  ? Rest<MakeTuple<N>>["length"]
  : never;

type Zero = 0;
type One = Increase<Zero>; // 1
type Two = Increase<One>; // 2
type Three = Increase<Two>; // 3

type Test3_2 = EqualTest<Decrease<Three>, Two>; // true
type Test2_1 = EqualTest<Decrease<Two>, One>; // true
type Test1_0 = EqualTest<Decrease<One>, Zero>; // true
```

下面实现算术：

```tsx
type Plus<A extends number, B extends number> = B extends 0
  ? A
  : Decrease<B> extends number
  ? Increase<A> extends number
    ? Plus<Increase<A>, Decrease<B>>
    : never
  : never;

type Five = Plus<3, 2>; // 5
type Eight = Plus<5, 3>; // 8

type Subtract<A extends number, B extends number> = B extends 0
  ? A
  : A extends 0
  ? never
  : Decrease<A> extends number
  ? Decrease<B> extends number
    ? Subtract<Decrease<A>, Decrease<B>>
    : never
  : never;

type SubtractTestsImpl<A extends number, Bs extends number> = {
  [B in Bs as `${A}-${B}`]: Subtract<A, B>;
};

type SubtractTests = SubtractTestsImpl<
  10,
  1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11
>;
```

以下是输出结果：

![截屏2023-01-13 下午12.12.52.png](TypeScript%20%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D%20c3a034e447904ab998e3e1f2197eda94/%25E6%2588%25AA%25E5%25B1%258F2023-01-13_%25E4%25B8%258B%25E5%258D%258812.12.52.png)

还有自然数乘法的实现：

```tsx
type Times<
  A extends number,
  B extends number,
  Sum extends number = 0
> = B extends 0
  ? Sum
  : Decrease<B> extends number
  ? Times<A, Decrease<B>, Plus<Sum, A>>
  : never;

type TimesTestImpl<A extends number, Bs extends number> = {
  [B in Bs as `${A} * ${B}`]: Times<A, B>;
};

type TimesTests = TimesTestImpl<6, 1 | 2 | 3 | 4 | 5>;
```

以下是测试结果：

![截屏2023-01-13 下午12.25.31.png](TypeScript%20%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D%20c3a034e447904ab998e3e1f2197eda94/%25E6%2588%25AA%25E5%25B1%258F2023-01-13_%25E4%25B8%258B%25E5%258D%258812.25.31.png)

## 函数型类型对象相关的操纵方法与类型推导方法

函数是 JavaScript/TypeScript 中非常常见的对象，理解掌握函数类型相关的类型对象的操作方法对我们编写更加鲁棒、清晰易读的 TypeScript 代码有帮助。

### 函数型类型对象的参数类型和返回值类型的推导

假设 `FuncT` 是一个确定的函数类型，那么我们可以通过 `infer` 关键字让编译器推导 (’infer’ 的字面含义）出这个函数类型的各个部分，包括它的参数类型和它的返回值类型：

```tsx
// 获取函数参数类型
type GetParametersAsNamedTuple<T> = T extends (...args: infer X) => infer _
  ? X
  : never;
```

接下来我们定义两个函数类型，用来验证这个 `GetParametersAsNamedTuple` 能否按预期工作：

```tsx
type MyFuncType1 = (a: number, b: string, c: boolean) => number;
type MyFuncType2 = () => void;
```

通过这样的类型声明语句，将鼠标悬浮在新声明的类型上，我们可以看到结果：

```tsx
type P1 = GetParametersAsNamedTuple<MyFuncType1>; // [a: number, b: string, c: boolean]
type P2 = GetParametersAsNamedTuple<MyFuncType2>; // []
```

同样可以让编译器 infer 出函数类型的返回类型：

```tsx
// 获取函数返回值类型
type GetReturnType<T> = T extends (...args: infer _) => infer X ? X : never;
```

使用方式如下：

```tsx
type R1 = GetReturnType<MyFuncType1>; // number
type R2 = GetReturnType<MyFuncType2>; // void
```

### 函数型类型对象的参数类型和返回值类型的推导

我们已经实现将函数类型的函数参数类型提取出来的方法（以范型类型的形式体现），以及对 Tuple 类型对象的操纵方法，例如 `ConcatTuple` , 那么接下来我们可以顺理成章地开始尝试对函数参数类型的修改。

先声明一个函数类型构造器，它接受一个 Tuple 类型对象和一个返回类型对象，前者描述函数类型的参数类型，后者描述函数类型的返回值类型：

```tsx
// 由参数列表（一个 NamedTuple Type）和返回值类型构造一个函数类型
type NamedTupleToFunctionType<ParameterT extends [...any], ReturnT> = (
  ...args: ParameterT
) => ReturnT;
```

有了这个 `NamedTupleToFunctionType` 类型函数再结合 `infer` 关键字，我们可以实现很灵活的函数操纵功能，无论是通过它提取函数的参数类型和返回值类型，还是拿着具体的类型去构造一个函数类型都很方便。

下面我们来实现参数类型的增加，它可以在一个函数现有参数列表的基础上，再加上一个或者若干个参数，它通过 `infer` 出 `NamedTupleToFunctionType` 的参数，然后再用 `NamedTupleToFunctionType` 构造新的函数类型来实现：

```tsx
// 给函数增加一个（或多个）参数
type AddParams<
  FuncT,
  ParamsT extends [...any]
> = FuncT extends NamedTupleToFunctionType<infer P, infer R>
  ? NamedTupleToFunctionType<ConcatTuple<P, ParamsT>, R>
  : never;
```

声明一个函数类型用来试验一下：

```tsx
type MyFuncType4 = AddParams<
  (x: number, y: string) => void,
  [z: number[][], a: boolean]
>; // (x: number, y: string, z: number[][], a: boolean) => void
```

用类似的思路我们可以尝试用 `NamedTupleToFunctionType` 类型函数来修改一个函数类型的返回值类型：

```tsx
// 修改函数的返回值类型
type OverrideFunctionReturnType<FuncT, NewReturnT> =
  FuncT extends NamedTupleToFunctionType<infer P, infer _>
    ? NamedTupleToFunctionType<P, NewReturnT>
    : never;
type MyFuncType5 = OverrideFunctionReturnType<
  (a: Array<string>) => void,
  boolean
>;
```

### 函数型类型对象的函数组合的结果的类型对象的推导

对于一元函数 `A => B` 和 `C => D`, 若 `B` == `C`, 我们就说这两个函数是可组合的。假设 `FuncType1` 和 `FuncType2` 是这两个函数各自的类型，我们希望实现一个类型函数 `CompositionType` 来描述这两个函数组合后的类型。

通过 `infer` 关键字（类型推导）和 `extends` 关键字（模式匹配）可以轻松实现：

```tsx
type CompositionType<F1, F2> = F1 extends (...x: infer X) => infer Y
  ? F2 extends (x: Y) => infer Z
    ? (...args: X) => Z
    : never
  : never;
let f: (a: string, b: number) => boolean;
let g: (a: boolean) => string[];
type F = typeof f;
type G = typeof g;
type GF = CompositionType<F, G>; // (a: string, b: number) => string[]
```

### 函数型类型对象的相应柯里化处理结果的函数类型的推导

在实现函数类型的柯里化的类型函数之前，我们需要一个辅助函数：

```tsx
// 由参数列表和返回类型构造函数类型
type FuncMaker<ParamsT, ReturnT> = ParamsT extends [...any]
  ? (...args: ParamsT) => ReturnT
  : never;
```

它的使用方式是这样：

```tsx
type F1 = FuncMaker<[], void>; // () => void
type F2 = FuncMaker<[a: boolean], void>; // (a: boolean) => void
type F3 = FuncMaker<[boolean, string], void>; // (_arg0: boolean, _arg1: string) => void
type F4 = FuncMaker<
  [p1: boolean, p2: string, p3: number[][], p4: object],
  number[]
>;
// (p1: boolean, p2: string, p3: number[][], p4: object) => number[]
```

这个 `FuncMaker` 类型函数实际上我们之前已经实现过了，只不过是名字更短了而已。

直接实现由普通多元函数类型转为相应的柯里化函数类型的类型函数比较麻烦，因此我们走曲线救国路线，先假定函数的参数类型（元组或者具名元组形式的）和返回值类型已经拿到了，并且把这两个类型视为参数，就可以得到这样一个特殊版本的柯里化实现：

```tsx
// 由参数列表和返回值类型构造柯里化函数类型
type CurryFuncMaker<ParamsT, ReturnT> = ParamsT extends []
  ? FuncMaker<[], ReturnT>
  : ParamsT extends [infer HeadParamT]
  ? FuncMaker<[HeadParamT], ReturnT>
  : ParamsT extends [infer HeadParamT, ...infer Rest]
  ? FuncMaker<[HeadParamT], CurryFuncMaker<Rest, ReturnT>>
  : never;
```

它的使用方式是这样的：

```tsx
type CF1 = CurryFuncMaker<[a: string, b: number, c: number[]], boolean>;
// (_: string) => (_: number) => (_: number[]) => boolean
```

接下来只需用 `infer` 关键字解析出函数的参数类型和返回值类型就可以直接实现函数类型的柯里化了：

```tsx
// 将一个多对一函数类型转为一个柯里化函数类型
type Currifying<FuncT> = FuncT extends FuncMaker<infer ParamsT, infer ReturnT>
  ? CurryFuncMaker<ParamsT, ReturnT>
  : never;
```

它的使用方式是这样：

```tsx
let myFunc1: (a: string[], b: boolean, c: number[][], d: object) => boolean;
type CF2 = Currifying<typeof myFunc1>;
// (_: string[]) => (_: boolean) => (_: number[][]) => (_: object) => boolean
```

通过这个例子我们发现类型函数也具有支持递归调用自身，并且利用这个特性可以实现很强大的功能。

## 对象类型的方操纵与推导方法

对象是我们在 JavaScript 和 TypeScript 中遇到的最多的东西，一个对象是一系列键值对的组合并且这里的「值」本身还可以是对象，也就是说对象其实可视作可嵌套的键值对列表，并且在 JavaScript 和 TypeScript 中，由于对象的使用是如此地频繁，语言本身提供了像 <objExpr> . <keyName> 和 <objExpr> [ <keyExpr> ] 这样的对象属性访问方式，使得对象的使用变得方便。

但是由于对象的属性名并不好记，也容易拼错，所以一般在工程实践中，人们会用 TypeScript 定义变量作为对象它所属的具体类型，这样在编码的过程中可以体会到 IDE 到自动提词带来的便捷，以及使得编译器的编译期静态检查功能得以开展。

下面我们来说说对象类型的操纵。

### 对象类型的构造

TypeScript 语言提供了 `in` 关键字，该关键字允许我们在 TypeScript 构造语句中遍历一个 Union 类型的所有成员，如下所示：

```tsx
// 用 key 构造 object 类型
type ConstructObjectTypeByKey<T extends string, ValueT> = {
  [KeyT in T]: ValueT;
};
```

在某些情形下，我们可以这一点来方便地构造类型，而不用把一个类型完整地写出来，例如：

```tsx
type Foo = ConstructObjectTypeByKey<"foo" | "bar" | "baz", number[]>;
// type Foo = {
//   foo: number[];
//   bar: number[];
//   baz: number[];
// }
```

我们也可以检验一下以这种方式声明出来的这个对象它满足哪些性质：

```tsx
type IsFooExtendsObject = Foo extends object ? true : false; // true
type IsFooExtendsArrayOfObject = Foo extends object[] ? true : false; // false
type IsFooExtendsItSelf = Foo extends Foo ? true : false; // true
```

### 对象类型字段的推导

虽然 TypeScript 语言提供了 `keyof` 关键字，它以 Union 类型的形式返回一个 object 对象它具备的字段名称（所以实际上是 Union of Literal Types），但是我们还是可以借助于 `infer` 关键字来实现它，正如同我们一开始针对函数类型所做的那样：

```tsx
// 用 infer 类型推导功能实现 keyof 操作符
type InferBasedKeyof<T> = T extends ConstructObjectTypeByKey<infer KeysT, any>
  ? KeysT
  : never;
type KeysOfFoo = InferBasedKeyof<Foo>; // "foo" | "bar" | "baz"
```

### 对象类型的修饰

但是除了 `keyof` 关键字之外，TypeScript 还提供了真的类型的字段遍历功能和字段修饰功能，下面我们可以来试着给字段加上可选修饰符，例如把 `{ foo: number; }` 变成一个 `{ foo?: number | undefined; }` :

```tsx
// 给一个 object 类型的各字段都加上 optional 修饰（? 修饰，也叫问号修饰）
type AddOptionalToFields<T extends object> = {
  [Property in keyof T]+?: T[Property];
};
```

这里主要是用到了加号 `+` 和问号 `?`, 它们在 TypeScript 的特定上下文中可以有特定的功能。

这样的类型修饰函数使用起来也是非常的方便：

```tsx
type OptionalFoo = AddOptionalToFields<Foo>;
// type OptionalFoo = {
//   foo?: number[] | undefined;
//   bar?: number[] | undefined;
//   baz?: number[] | undefined;
// }
```

要去掉可选修饰符，只需把加号改成减号就可以了：

```tsx
// 去掉 optional 修饰
type RemoveOptionalFromFields<T extends object> = {
  [Property in keyof T]-?: T[Property];
};

type NonOptionalFoo = RemoveOptionalFromFields<OptionalFoo>;
type IsNonOptionalFooExtendsFoo = NonOptionalFoo extends Foo ? true : false; // true
```

### 对象类型的递归修饰

到目前为止，虽然我们一个 JavaScript 都没声明出来过，但是读者可以发现我时不时地会提到「类型函数」这个概念，实际上类型函数也是类型，具体来说是范型，它的作用就像函数那样，你传给他一个类型，它可以给你返回一个处理过的类型，并且它实际上也支持递归：

```tsx
// 递归地去掉 optional 修饰
type RecursivelyRemoveOptionalFromFields<T> = T extends object
  ? {
      [Property in keyof T]-?: RecursivelyRemoveOptionalFromFields<T[Property]>;
    }
  : T;

type SomeNestedOptionalType = {
  a1?: {
    a2?: {
      a3?: number;
    };
  };
  b?: number[][];
  c?: boolean;
};

type SomeNoOptionalType =
  RecursivelyRemoveOptionalFromFields<SomeNestedOptionalType>;

// 递归地加上 optional 修饰
type RecursivelyAddOptionalToFields<T> = T extends object
  ? {
      [Property in keyof T]+?: RecursivelyAddOptionalToFields<T[Property]>;
    }
  : T;

type OptionalA = RecursivelyAddOptionalToFields<SomeNoOptionalType>;
```

由此可见类型函数的强大。

### 对象类型的可选与非可选字段的提取

前面我们演示了 TypeScript 提供的真的对象类型的遍历和修饰功能，但是修饰功能那是针对字段的值类型的，下面我们会发现字段本身也能被修饰：通过 `as` 关键字，以及可以通过在遍历过程中对一个字段名 `as never` 来把它移出：

（其中 `NullableTest` 的声明见文章后面对联合类型的讲解）

```tsx
// 分支范型
type If<Cond, TrueT, FalseT> = Cond extends true ? TrueT : FalseT;

// 获取非 optional 字段
type ExtractNonOptionalProperties<T extends object> = {
  [Key in keyof T as If<NullableTest<T[Key]>, never, Key>]: T[Key];
};

type MixedType1 = {
  a?: "foo" | "bar";
  b?: number[][];
  c: boolean;
  d: number;
};

type NonOptionalOnMixedType1 = ExtractNonOptionalProperties<MixedType1>;
// Output: { c: boolean; d: number; }

// 获取 optional 字段
type ExtractOptionalProperties<T extends object> = {
  [Key in keyof T as If<NullableTest<T[Key]>, Key, never>]: T[Key];
};

type NonOptionalOnMixedType2 = ExtractOptionalProperties<MixedType1>;
// Output: { a?: 'foo' | 'bar' | undefined; b?: number[][] | undefined; }
```

### 对象类型的合并

通过 ‘&’ 符号可以合并两个类型，并且得到一个同时包含各自所含字段的类型：

```tsx
type Foo = { foo: number[]; foo1: string[][] };
type Bar = { foo: object };
type Foo_Bar = Foo & Bar;
type Test = Foo_Bar["foo"] extends object ? true : false;
```

但是这种方法有一个不方便的地方就是编译器给出的提示信息不够友好，将鼠标 hover 置合成类型 `Foo_Bar` 标识符上方时，用户看到的是：

![截屏2023-01-13 下午11.40.13.png](TypeScript%20%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D%20c3a034e447904ab998e3e1f2197eda94/%25E6%2588%25AA%25E5%25B1%258F2023-01-13_%25E4%25B8%258B%25E5%258D%258811.40.13.png)

反正就是看不清 `Foo_Bar` 具体包含哪些字段，只看到 `Foo` & `Bar` 这样的提示，几乎等于什么都没说。

我们想要的效果是查看 `Foo`, `Bar` 这两个类型合并后有哪些字段，如果一个字段同时在 `Foo`, 在 `Bar` 里出现，那就以 `Bar` 里出现的那个为准，以下是实现，它运用了 TypeScript 提供的对象类型遍历功能、对联合类型的支持以及模式匹配功能：

```tsx
type TypeMerge<T, S> = {
  [Key in keyof (T & S)]: Key extends keyof S
    ? S[Key]
    : Key extends keyof T
    ? T[Key]
    : never;
};
```

假设要合并的类型是这样的：

```tsx
type Foo = {
  foo: number[];
  foo1: string[][];
  foo2: boolean;
  foo3: { b: boolean };
};
type Bar = { foo: object; foo1: number[] };

type Foo_Bar = TypeMerge<Foo, Bar>;
```

这时候可以看到清晰的合并后的类型：

![截屏2023-01-14 下午2.35.39.png](TypeScript%20%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D%20c3a034e447904ab998e3e1f2197eda94/%25E6%2588%25AA%25E5%25B1%258F2023-01-14_%25E4%25B8%258B%25E5%258D%25882.35.39.png)

## 联合类型的操纵

联合类型其实就是不确定的类型，当它作为一个变量的声明类型的时候，它要表达的意思是：这个变量的值可能是这个类型也可能是那个类型还可能是那个类型，比如说：

```tsx
let a: A | B | C | undefined;
```

这句声明语句说的就是变量 `a` 的值可能是类型 `A` 的，类型 `B` 的，类型 `C` 的甚至还可能没有值（也就是 `undefined`）。

`never` 用来表示一个空的联合类型，它表示一个没有囊括任何类型的联合类型。

联合类型的概念有点类似于数学中「集合」的概念，这样子你就能够更好地理解 `never` 了：它表示的就是空集。

注意 `void` 不是 `never`, `void` 也不属于 `never` , `void` 是一个无论怎样执行都不返回值的函数的返回类型，当编译器遇到一个不返回值并且没有显式声明的返回类型的函数时，就会推断它的类型为 `void` ，当然我们也可以手动声明它的返回值类型为 `never` ，不过这是两码事。

`never`, `void`, `undefined`, `null` 它们之间的关系和差别不在本文的讲述范围内。

```tsx
let myFunc = () => {};
type ReturnTypeOf<T> = T extends (...args: infer _) => infer R ? R : never;
type TypeOfMyFunc = ReturnTypeOf<typeof myFunc>; // void
```

那么既然是集合，就有集合与集合之间子集关系的判定，在 TypeScript 中用 `extends` 关键字表示。

值得一提的是集合之间的子集关系是一个偏序关系，它满足：

1. 自反性(Reflexivity): 任何集合都是自己的子集；
2. 反向对称性(Antisymmetry): 对任意集合 a, b, 若 a 是 b 的子集，b 也是 a 的子集，则表示 a 和 b 是相等的，换句话说：不存在不一样的 a, b 使得 a 是 b 的子集和 b 是 a 的子集同时成立；
3. 传递性(Transitivity): 若 a 是 b 的子集，b 是 c 的子集，那么 a 是 c 的子集；

围绕着联合类型，在 TypeScript 中还有 Type Guard 和 Type Narrowing 等概念可以讲，但是不在本文讨论范围内。

### 联合型类型对象的子集关系判定

这种判定得以实现基于这样的事实：

命题 1: 对任意集合 $A, B$, $A \subset B$ 的充分必要条件是 $A \cup B \subset B$。

证明：

必要性：

若 $A \subset B$, 则 $A \cup B \subset B$ 是显然成立的。

必要性得证。

充分性：

现在我们希望证明当 $A \cup B \subset B$ 成立时 $A \subset B$ 也成立。

为此我们采用反证法，假设 $A \not\subset B$, 那么存在 $x_0 \in A$ 并且 $x \not\in B$，由于 $x \in A$ 所以 $x \in A \cup B$，可是由于 $x \in A \cup B$ 并且 $x \not \in B$，所以 $A \cup B \not\subset B$, 矛盾。

充分性得证。

那么基于这个论断，我们就可以直接写出集合，啊不，联合类型的从属关系的判定的类型函数：

```tsx
// Union 从属关系判定：若 T 是联合类型 U 的子集，返回 true, 否则返回 false
type UnionElementTest<T, U> = U | T extends U ? true : false;
```

通过下列实例验证一下它是否能够正常工作：

```tsx
type E1 = UnionElementTest<number, number>; // true
type E2 = UnionElementTest<void, number>; // false
type E3 = UnionElementTest<number, number | string>; // true
type E4 = UnionElementTest<string, number | string>; // true
type E5 = UnionElementTest<boolean, number | string>; // false
type E6 = UnionElementTest<number | string, string>; // false
type E7 = UnionElementTest<never, string>; // true

// 是否值类型元素（类型分为值类型和引用类型）
type IsValueType<T> = UnionElementTest<
  T,
  number | string | boolean | undefined | null | symbol
>;
type IV1 = IsValueType<number>; // true
type IV2 = IsValueType<number[]>; // false
type IV3 = IsValueType<object>; // false
type IV4 = IsValueType<"a">; // true, because 'a' extends string.
```

### 联合型类型对象的假性判定

这个小小的 `OR` 类型函数和前面刚实现的 `UnionElementTest` 类型函数配合起来又可以实现一个新功能：`NullableTest`

```tsx
// 是否 null 或者 undefined
type NullableTest<T> = Or<
  UnionElementTest<null, T>,
  UnionElementTest<undefined, T>
>;
type IO1 = NullableTest<undefined>; // true
type IO2 = NullableTest<null>; // true
type IO3 = NullableTest<number | null>; // true
type IO4 = NullableTest<number | undefined>; // true
type IO5 = NullableTest<string[] | object[][] | undefined>; // true
type IO6 = NullableTest<number>; // false
type IO7 = NullableTest<string[]>; // false
type IO8 = NullableTest<object>; // false
```

### 联合型类型对象可以由由 Tuple 型类型对象来构造

下面这个例子结合了 `infer` 关键字，递归函数和 union 操作，实现了 Tuple 到 Union 的转换：

```tsx
// Tuple 转 Union
type TupleToUnion<T extends [...any]> = T extends []
  ? never
  : T extends [infer X, ...infer Y]
  ? X | TupleToUnion<Y>
  : never;
type UnionFromTuple = TupleToUnion<[string, number, object]>; // string | number | object
```

### 联合型类型对象的等性判定

正如同集合的等被定义为 $A \subset B$ 并且 $B \subset A$ 同时成立一样，由于 Union 类型和集合对象的性质是类型的（换句话说它们有相似的数学结构），我们也可以类似地实现联合类型（或者更一般地说：类型）的等价性判定：

```tsx
// 等性判定
type EqualTest<T, S> = T extends S ? (S extends T ? true : false) : false;
```

### 联合型类型对象用于实现元组元素关系判定

有了 `EqualTest` 的实现，我们可以这样判断一个元素在不在一个 Tuple 中：一个元素在一个 Tuple 中的定义是在这个 Tuple 中存在一个元素等于它：

```tsx
// Tuple 从属关系判定：是否 TupleT 非空并且存在 TupleT 中的某个元素 T 使得 EqualTest<T, EleT> extends true 成立？
type TupleElementTest<EleT, TupleT> = TupleT extends []
  ? false
  : TupleT extends [infer HeadT, ...infer Rest]
  ? Or<EqualTest<EleT, HeadT>, TupleElementTest<EleT, Rest>>
  : false;

type TE1 = TupleElementTest<string, []>; // false
type TE2 = TupleElementTest<string, [string]>; // true
type TE3 = TupleElementTest<number, [string]>; // false
type TE4 = TupleElementTest<number, [string, number]>; // true
type TE5 = TupleElementTest<number[], [string, number]>; // false
type TE6 = TupleElementTest<number[], [string, number[], number]>; // true
```

## 布尔型类型对象的常用操纵方法

### 「逻辑或 OR」类型函数的实现

联合类型的 union 运算（加法运算）可以用来方便地模拟布尔对象的 OR 运算，因此，我们可以这样实现类型对象的 OR 运算，具体是通过一个类型函数：

```tsx
// 或者
type Or<Cond1, Cond2> = true | Cond1 | Cond2 extends Cond1 | Cond2
  ? true
  : false;
type O1 = Or<false, false>; // false
type O2 = Or<false, true>; // true
type O3 = Or<true, false>; // true
type O4 = Or<true, true>; // true
```

在更好地理解「联合类型」和 `extends` 关键字的基础上，或许聪明的读者会想到这么实现 `OR` 类型函数：

```tsx
type Or<Cond1, Cond2> = true extends Cond1 | Cond2 ? true : false;

type O1 = Or<false, false>; // false
type O2 = Or<false, true>; // true
type O3 = Or<true, false>; // true
type O4 = Or<true, true>; // true
```

我个人觉得这种方法更好。

### 「逻辑与 AND」类型函数的实现

两个布尔代数对象的逻辑与运算结果为真当且仅当这两个中没有任何可被求值为 `false`, 也就是说：

```tsx
type And<Cond1, Cond2> = false extends Cond1 | Cond2 ? false : true;

type A1 = And<false, false>; // false
type A2 = And<false, true>; // false
type A3 = And<true, false>; // false
type A4 = And<true, true>; // true
```

### 「逻辑非 NOT」类型函数的实现

```tsx
type Not<T extends boolean> = T extends true ? false : true;

type No1 = Not<true>; // false
type No2 = Not<false>; // true
```

### 「逻辑异或 XOR」类型函数的实现

对于 `Xor` 类型函数来说，它只有在它的两个输入不等时，才返回真：

```tsx
type Xor<Cond1, Cond2> = Not<
  And<Cond1 extends Cond2 ? true : false, Cond2 extends Cond1 ? true : false>
>;

type X1 = Xor<false, false>; // false
type X2 = Xor<false, true>; // true
type X3 = Xor<true, false>; // true
type X4 = Xor<true, true>; // false
```

## 字符串型类型对象的操纵与模式匹配方法

字符串是有限多个字符组成的有序序列，在各种常见的编程语言中往往都有字符串类型，将一个变量声明为字符串可以让编码人员知道：「哦，这个标识符绑定的是一个字符串对象，不是数字，也不是数组或者对象之类的」，然后 IDE（或者编辑器的提示模块）就可以根据这个变量的类型声明知道它是指向字符串对象的引用，当键入形如 <expr> . 这样的表达式时，IDE 就可以提示字符串的方法，而不是数字，数组，或者某种原型的对象的操作方法：

![截屏2023-01-10 上午1.16.25.png](TypeScript%20%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D%20c3a034e447904ab998e3e1f2197eda94/%25E6%2588%25AA%25E5%25B1%258F2023-01-10_%25E4%25B8%258A%25E5%258D%25881.16.25.png)

在 TypeScript 中也有一种习惯，就是用一种被称为 String Literal Types 的类型来做在其他语言中，枚举类型做的事（实际上在 TypeScript 中也有枚举，见 `enum` 关键字），但实际上，根据字符串的定义，String Literal Types 也都是 `string` 类型的子类型，例如说：

```tsx
type Animal = "Cat" | "Dog" | "Duck" | "Tiger";
type IsAnimalString = Animal extends string ? true : false; // true
```

对于熟悉编程语言理论，尤其是类型系统相关的知识的读者来说，理解 String Literal Types 是 `string` 的子类型这件事是很自然的，因为类型可以由集合来定义，而很显然 `Animal` 每种可能的取值都在 `string` 集中。

### 字符串型类型对象的连接操作

前面我们说过，类型在 TypeScript 中的地位就好比 object 在 JavaScript 中的地位一样，实质上类型本身也可以看作对象，字符串类型对象之间也可以相「加」「减」，由于 TypeScript 语言提供的 Template Literal Type 功能，字符串类型对象的「加法」实现起来是很自然的：

```tsx
type ConcatString<A extends string, B extends string> = `${A}${B}`;
type Hello = "hello, ";
type World = "world!";
type HelloWorld = ConcatString<Hello, World>;
// type HelloWorld = 'hello, world!'
```

实际上这体现不出什么，但是如果我们有这样一个关于 String Literal Types 的联合类型，需要让其中的每一个都和一个字符串连接，以此产生一个新的类型，这时使用这个 `ConcatString` 类型函数就会比较方便了：

```tsx
type Fruit = "Apple" | "Orange" | "Lemon" | "Banana";
type FruiteJuice = ConcatString<Fruit, "Juice">;
// type FruiteJuice = 'AppleJuice' | 'OrangeJuice' | 'LemonJuice' | 'BananaJuice'
```

### 字符串型类型对象的模式匹配操作

不仅可以连接已有的字符串类型对象得到新的字符串类型对象，结合 Template Literal Types 功能和 `infer` 关键字（类型推导与模式匹配功能），还可以把一个子串从字符串中提取出来以构造一个类型对象：

```tsx
type WhatFruit<JuiceT> = JuiceT extends `${infer FruitT}Juice`
  ? FruitT
  : unknown;
type WhatFruitInOrangeJuice = WhatFruit<"OrangeJuice">; // 'Orange'
type FruitesInFruiteJuices = WhatFruit<FruiteJuice>; // 'Apple' | 'Orange' | 'Lemon' | 'Banana';
type Celery = WhatFruit<"CeleryJuice">; // 'Celery'
```

### 字符串型类型对象模拟的自然数运算操作

如果用字符串表示正整数的话，0 可以被表示成空字符串，数字每加一，就让字符串的长度加一，这样就可以把正整数集的每一个元素都映射到字符串集当中。

我们可以用这种方式实现正整数的算术运算，主要是加法和乘法：

```tsx
type PlusOne<T extends string> = `1${T}`;
type SubtractOne<T extends string> = T extends `1${infer RemainderT}`
  ? RemainderT
  : Zero;
type Plus<A extends string, B extends string> = B extends Zero
  ? A
  : Plus<PlusOne<A>, SubtractOne<B>>;

type Zero = "";
type One = PlusOne<Zero>;
type Two = Plus<One, One>;
type Three = PlusOne<Two>;
type Four = Plus<Two, Two>;
type Five = PlusOne<Four>;
type Eight = Plus<Four, Four>;
type Nine = PlusOne<Eight>;
type Ten = Plus<Eight, Two>;
type Sixteen = Plus<Eight, Eight>;

type PowerOfTwoImpl<
  Sum extends string = One,
  Count extends string = Zero
> = Count extends Zero
  ? Sum
  : PowerOfTwoImpl<Plus<Sum, Sum>, SubtractOne<Count>>;
type PowerOfTwo<N extends string> = PowerOfTwoImpl<PlusOne<One>, N>;
type N512 = PowerOfTwo<Nine>;

type TimesImpl<
  A extends string,
  B extends string,
  C extends string
> = B extends Zero ? C : TimesImpl<A, SubtractOne<B>, Plus<C, A>>;
type Times<A extends string, B extends string> = TimesImpl<A, B, Zero>;
type Twelve = Times<Three, Four>;
type Forty = Times<Five, Eight>;
```

在这些加法、乘法运算函数的基础上，可以实现前 N 个正整数的求和类型函数：

```tsx
type NaturalSumImpl<A extends string, B extends string> = B extends Zero
  ? A
  : NaturalSumImpl<Plus<A, B>, SubtractOne<B>>;
type NaturalSum<A extends string> = NaturalSumImpl<Zero, A>;
type IsOneEqualsOne = NaturalSum<One> extends One ? true : false;
type IsThreeEqualsThree = NaturalSum<Two> extends Three ? true : false;
type FiftyFive = NaturalSum<Ten>;
type IsFiftyFiveEqualsFiftyFive = Plus<Times<Ten, Five>, Five> extends FiftyFive
  ? true
  : false;
```

**但是以上不是 TypeScript 类型编程中实现算术的唯一的方式。**

### 字符串型类型对象用于给定长度的元组型类型对象的创建

以上我们实现了和自然数类似的一种类型，因为我们用类型对象定义了「零」并且用类型函数定义了「自增」，随后，自然数支持的操作都可以用类型函数的方式来实现。

那么作为一个应用，我们可以用我们刚实现的「自然数」类型来实现一个类型函数，它支持创建由 N 个 `undefined` 类型构成的元组类型：

```tsx
type DuplicatedTupleImpl<N extends string, T extends [...any]> = N extends Zero
  ? T
  : DuplicatedTupleImpl<SubtractOne<N>, [undefined, ...T]>;
type DuplicatedTuple<N extends string> = DuplicatedTupleImpl<N, []>;
type DT0 = DuplicatedTuple<Zero>; // []
type DT1 = DuplicatedTuple<One>; // [undefined]
type DT2 = DuplicatedTuple<Two>; // [undefined, undefined]
type DT3 = DuplicatedTuple<Three>; // [undefined, undefined, undefined]
type DT4 = DuplicatedTuple<Four>; // [undefined, undefined, undefined, undefined]
```

### 字符串型类型对象的其他构造方式

按照模式匹配的思路，我们可以像这样实现数字字符串到「自然数」类型对象的转换的类型函数：

```tsx
type DigitMap = [
  Zero,
  One,
  Two,
  Three,
  Four,
  Five,
  Six,
  Seven,
  Eight,
  Nine,
  Ten
];

type StrToNumImpl<
  Str extends string,
  SumValue extends string
> = Str extends Zero
  ? SumValue
  : Str extends `0${infer RestStr}`
  ? StrToNumImpl<RestStr, Plus<Times<SumValue, Ten>, DigitMap[0]>>
  : Str extends `1${infer RestStr}`
  ? StrToNumImpl<RestStr, Plus<Times<SumValue, Ten>, DigitMap[1]>>
  : Str extends `2${infer RestStr}`
  ? StrToNumImpl<RestStr, Plus<Times<SumValue, Ten>, DigitMap[2]>>
  : Str extends `3${infer RestStr}`
  ? StrToNumImpl<RestStr, Plus<Times<SumValue, Ten>, DigitMap[3]>>
  : Str extends `4${infer RestStr}`
  ? StrToNumImpl<RestStr, Plus<Times<SumValue, Ten>, DigitMap[4]>>
  : Str extends `5${infer RestStr}`
  ? StrToNumImpl<RestStr, Plus<Times<SumValue, Ten>, DigitMap[5]>>
  : Str extends `6${infer RestStr}`
  ? StrToNumImpl<RestStr, Plus<Times<SumValue, Ten>, DigitMap[6]>>
  : Str extends `7${infer RestStr}`
  ? StrToNumImpl<RestStr, Plus<Times<SumValue, Ten>, DigitMap[7]>>
  : Str extends `8${infer RestStr}`
  ? StrToNumImpl<RestStr, Plus<Times<SumValue, Ten>, DigitMap[8]>>
  : Str extends `9${infer RestStr}`
  ? StrToNumImpl<RestStr, Plus<Times<SumValue, Ten>, DigitMap[9]>>
  : never;

type StrToNum<Str extends string> = StrToNumImpl<Str, Zero>;
type S0 = StrToNum<"0">; // S0 extends Zero
type S1 = StrToNum<"1">; // S1 extends One
type S2 = StrToNum<"2">; // S2 extends Two
type S3 = StrToNum<"3">; // S3 extends Three

type S21 = StrToNum<"21">;
type S22 = StrToNum<"22">;
type S23 = StrToNum<"23">;
type S24 = StrToNum<"24">;

type S21Test = S21 extends Plus<Times<Two, Ten>, One> ? true : false;
type S22Test = S22 extends Plus<Times<Two, Ten>, Two> ? true : false;
type S23Test = S23 extends Plus<Times<Two, Ten>, Three> ? true : false;
type S24Test = S24 extends Plus<Times<Two, Ten>, Four> ? true : false;
```

### 字符串型类型对象到字符元组的转换操作

此功能要求被分割的那个字符串型类型对象是确定的或者确定的联合类型，虽然 `string` extends `string` 是真，但是直接传入 `string` 对 `string` 本身进行分割是不允许的。

此功能依赖于 TypeScript 在 Template Literal Type 中进行模式匹配时只匹配第一个字符，也就是说：

```tsx
type GetFirstChar<T> = T extends `${infer X}${infer _}` ? X : never;
```

并且当：

```tsx
type TestGetFirstChar = GetFirstChar<"test"> extends "t" ? true : false;
```

的推导结果为 `true` 时才可以。

利用这个 `GetFirstChar` 类型函数可以实现分割字符串字面量类型的字符的功能：

```tsx
type StrToTupleOfChar<StrT extends string> = StrT extends ""
  ? []
  : [GetFirstChar<StrT>, ...StrToTupleOfChar<GetRestString<StrT>>];
```

对于空字符串，此类型函数会返回一个空的元组，而对于非空的字符串它会将匹配到的第一个字符放入到元组中，然后在对剩余的字符串递归调用自身。

按如下方式使用和测试：

```tsx
type CharsOfHello = StrToTupleOfChar<"hello">;
type TestCharsOfHello = CharsOfHello extends ["h", "e", "l", "l", "o"]
  ? true
  : false; // true
```

### 字符串型类型对象的子串查找操作

由于 TypeScript 提供的类型编程方法不直接支持针对整数的算术操作，所以为了记录 offset 的长度，我们把搜索/尝试匹配 Pattern 的过程中经过的字符保存在元组中，以下是这个思路的具体实现：

```tsx
type FindSubStringOffsetImpl<
  TraversedChars extends [...any],
  PatternStr extends string,
  Text extends string,
  Found extends boolean
> = Text extends ""
  ? PatternStr extends Text
    ? { found: true; prefixChars: TraversedChars }
    : { found: false; prefixChars: [] }
  : Text extends `${PatternStr}${infer _}`
  ? { found: true; prefixChars: TraversedChars }
  : FindSubStringOffsetImpl<
      [...TraversedChars, GetFirstChar<Text>],
      PatternStr,
      GetRestString<Text>,
      false
    >;
```

以下是它的使用截图：

![截屏2023-01-11 下午10.48.12.png](TypeScript%20%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D%20c3a034e447904ab998e3e1f2197eda94/%25E6%2588%25AA%25E5%25B1%258F2023-01-11_%25E4%25B8%258B%25E5%258D%258810.48.12.png)

这说明这个 `FindSubStringOffsetImpl` 类型函数已经开始工作了。

然而如果我们直接对它的返回结果做字段访问，例如 `TestSubstrFind['found']` 等，会遇到错误，虽然我们知道 FindSubStringOffsetImpl 一定会返回这个结构的类型对象，但是编译器还不够聪明。

为此我们再做一个辅助用途的类型函数，它是这样实现的：

```tsx
type SubStrSearchResult<
  FoundT extends boolean,
  PrefixCharsT extends [...any]
> = {
  found: FoundT;
  prefixChars: PrefixCharsT;
};
```

这样就方便把这两个字段关联到的类型对象提取出来了，就像在 JavaScript 里访问常规 object 一样（比如 `console.log(foo['bar'])` ），只不过我们这里操作的不是 object 而是类型。

那么接下来这个 `SubStrSearchResult` 是这么用的，相信在前文看过函数型类型对象操作章节的读者会有一点点熟悉这种声明一个辅助类型用来 infer 类型内部结构的这种套路：

```tsx
type FindSubStr<
  TextT extends string,
  PatternT extends string
> = FindSubStringOffsetImpl<
  [],
  PatternT,
  TextT,
  false
> extends SubStrSearchResult<infer FoundT, infer CharsT>
  ? FoundT extends true
    ? CharsT["length"]
    : -1
  : never;
```

这次我们不直接 index 访问了，而是定义一个结构，然后让编译器 infer 处理 `FoundT` 和 `CharsT`, 这时我们发现编译器还是足够聪明的。

这个 `FindSubStr` 可以实现子串匹配，如果找不到给定 Pattern 的子串则返回 -1, 否则返回 offset:

```tsx
type SO1 = FindSubStr<HelloWorld, "lo">; // 3
type SO2 = FindSubStr<HelloWorld, "ld">; // 10
type SO3 = FindSubStr<HelloWorld, "ald">; // -1
```

# 结论

通过这篇文章的讲述，我们发现，在 TypeScript 中，针对 type 的操纵方式是非常灵活的，掌握这些基本的类型操纵方法可以使得我们在开发过程中少写很多代码，并且更好地利用 TypeScript 的静态检查功能在编译时检查我们的代码。同时，在实际编码活动中应用这些类型操纵技巧也会给人带来一种心智上的愉悦感。
